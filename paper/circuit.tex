\section{Circuits}

The system will be working with a $V_{dd}$ of $1.8V$. Such a value was chosen because this is a low power system.

The way values are encoded in the analog system will be descibed here as it serves for the entire thesis.
In order for the system to support negative numbers we're going to use a $V_{cm}$ set to $\frac{V_{dd}}{2}$. That means that $V_{cm}=\frac{V_{dd}}{2}=0.9V$. This $V_{cm}$ will then describe a zero. A step of one was chosen to be $0.1V$ in the analog circuit.
\Cref{tab:valConv} shows the conversions from a real number to its voltage equivalent.

\begin{table}[b]
  \caption{Real/Voltage Conversion Table.}
  \label{tab:valConv}
  \centering
  \begin{tabular}{|c|c|}
    \hline
    \rowcolor{gray}
    Real value & Voltage \\
    \hline
    $0$ & $0.9V$ \\
    \hline
    $1$ & $1.0V$ \\
    \hline
    $x$ & $V(x)=\frac{x}{10}+V_{cm}$\\
    \hline
    $real(v)=(v-0.9)\cdot 10$ & $v$\\
    \hline
  \end{tabular}
\end{table}

Since the system cannot reach voltage outside of the operating range with the intended behavior, the voltage is then restricted to $V\in [0,1.8]$. This means that the range of real value that the systems can handle is $x\in [-9,9]$.

\subsection{Activation functions}\label{subsec:af}

Producing analog activation functions is quite important as using hard sigmoid or hard hyperbolic tangent (tanh) functions impacts the results \cite{af,hardSigm}.

The analog activation circuit thus plays an important role in the final result's quality.

The circuit used is the same as the one in \cite{thesisRef}, and is shown in \cref{circt:af}. The circuit's technology used being different, all the parameters had to be determined empirically to best fit a sigmoid shape. The parameters can be found in \cref{tab:afPar}.

Due to the nature of the functions we want to generate, we will use the same circuit for both a sigmoid and a \ac{tanh} like functions. The two different functions are generated by changing two parameters. The functions generated are the same shape and only differ by their output range.

\begin{figure}[t]
  \centering
  \includesvg[width=\columnwidth,pretex=\small]{activation/afCircuit}
  \caption{Activation functions circuit}
  \label{circt:af}
\end{figure}

\begin{table}[b]
  \caption{Circuits parameters}
  \label{tab:afPar}
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    \rowcolor{gray}
    Parameter & Sigmoid & \ac{tanh} \\
    \hline
    $V_1$ & \multicolumn{2}{c|}{$1.1V$}\\
    \hline
    $V_2$ & \multicolumn{2}{c|}{$635mV$}\\
    \hline
    $V_3$ & $0.8V$ & $550mV$\\
    \hline
    $i_{dc}$ & \multicolumn{2}{c|}{$150uA$}\\
    \hline
    $w$ & \multicolumn{2}{c|}{$900nm$}\\
    \hline
    $l$ & \multicolumn{2}{c|}{$60nm$}\\
    \hline
    $R_1$ & \multicolumn{2}{c|}{$5k\Omega$}\\
    \hline
    $R_2$ & \multicolumn{2}{c|}{$10k\Omega$}\\
    \hline
    $R_3$ & $2k\Omega$ & $4k\Omega$\\
    \hline
  \end{tabular}
\end{table}

Here, $w$ and $l$ are, respectively, the width and length of the two NMOS of the circuit.

The outputed voltage depends on the input passed on. The results obtained by are rather convincing and can be found in \cref{graph:af}. \Cref{graph:af} also shows the Root Mean Square Error (RMSE) of the analog results with the ideal result.

\begin{figure}[t]
  \centering
  \includesvg[width=\columnwidth, pretex=\scriptsize]{activation/afGraph}
  \caption{Input/Output graph of the activation function circuit for both sigmoid and \acs{tanh} functions}
  \label{graph:af}
\end{figure}

The symbols for the sigmoid and the \ac{tanh} are separated for better understanding and are available in \cref{sym:af}.

\begin{figure}[b]
  \centering
  \hspace*{0.8cm}
  \subfloat[Sigmoid symbol]{\includesvg[height=1cm,pretex=\small]{activation/sigmoidSymbol}}%
  \hfill
  \subfloat[\ac{tanh} symbol]{\includesvg[height=1cm,pretex=\small]{activation/tanhSymbol}}%
  \hspace*{0.8cm}
  \caption{Activation functions symbols with the input and output pins on either side depending on the flow of the current for better readability}
  \label{sym:af}
\end{figure}

These functions are still a bit different from the original functions (especially for the \ac{tanh}). However that does not matter too much as the trainning will be happening with the extracted analog functions, all weights will be set in the circuit. This is the reason why such a difference does not matter. As long as the curves have the similar shape, the result will not be drastically affected.

\subsection{Memory cell}

The memory cell is a circuit that is able to store an analog value for a limited time. It works using capacitors that have the ability to store a voltage for a short period of time.

The circuit is shown in \cref{circt:memcell}. The voltage is stored in the capacitor and is kept using \ac{CMOS} switches.

The \ac{CMOS} switches found in the circuit have width of $w=200nm$ and a length of $l=60nm$.

\begin{figure}[t]
  \centering
  \includesvg[width=\columnwidth,pretex=\small]{memcell/memCircuit}
  \caption{Memory cell circuit}
  \label{circt:memcell}
\end{figure}

%Remove first if too big
The cirucit has a two \ac{CMOS} switches design to avoid voltage leakage through the swicthes. The system has voltage leakage when only one \ac{CMOS} swicth, and thus leads to a large memory leak. This is due to the high voltage difference between the two sides of the \ac{CMOS} swicth. Using two \ac{CMOS} switches allows for this difference to be mitigated (\cref{fig:memcellLoss}).

\begin{figure}[b]
  \centering
  \includesvg[width=\columnwidth,pretex=\scriptsize]{memcell/data-loss}
  \caption{Memory conservation in a memory cell with 1 \ac{CMOS} switch vs 2 \ac{CMOS} swicthes}
  \label{fig:memcellLoss}
\end{figure}

The symbol, shown in \cref{sym:memcell}, for this circuit is designed to show a capacitor because it is its memory mechanism.

\begin{figure}[t]
  \centering
  \includesvg[height=1cm,pretex=\small]{memcell/memcellSymbol}
  \caption{Memory cell symbol with the input enable pin (top) and the output enable pin (bottom). The left and right pins are interchangebly the input and ouput for the sake of readability}
  \label{sym:memcell}
\end{figure}

\subsection{Voltage-driven crossbar circuit}\label{subsec:xbarCircuit}

The crossbar circuit theory has already been explained in the \cref{sec:state}. The actual implementation in the circuit is described here. The circuit is the one in \cref{circt:xbar}. The circuit depends on three parameters :

\begin{itemize}
  \item $n_i$ : The number of input for our crossbar array (not including bias for a more general circuit).
  \item $n_o$ : The number of parallel output for our crossbar array.
  \item $n_s$ : The serial size of our crossbar system.
\end{itemize}

\begin{figure}[b]
  \centering
  \includesvg[width=\columnwidth,pretex=\scriptsize]{crossbar/crossbarUse}
  \caption{Circuit of the crossbar array used in the final system ($n_i$, $n_o$, $n_s$)}
  \label{circt:xbar}
\end{figure}

In this work, the choice was made to use a two memristor per synapse architecture. Using two memristor per synapse doubles the area but doubles the weight range \cite{doubleMem} and allows to easily use negavite weights. The output voltage will be centered around $V_{cm}$ and be compliant with the standard set in \cref{tab:valConv}.

This design is the one that is used in \cite{doubleMem}. Let's assume that a given memristor has a resistance range of $R\in[R_{min},R_{max}]$, that means its conductance range is $\sigma \in [\sigma_{min},\sigma_{max}]$ (with $\sigma_{min}= \frac{1}{R_{max}}$ and $\sigma_{max}= \frac{1}{R_{min}}$). This design works using two \ac{opAmp} connected to $V_{cm}$ with the positive pin and the negative pin to the output of the crossbar array. \Cref{eq:doubleMem0,eq:doubleMem1,eq:doubleMem2} are describing how this architecture works. A simplified version of the double memristors per synapse circuit is also available in \cref{circt:doubleMem}.

\begin{figure}[t]
  \centering
  \includesvg[width=\columnwidth,pretex=\tiny]{crossbar/doubleMem}
  \caption{Simplified circuit of a double memristor per synapse architecture}
  \label{circt:doubleMem}
\end{figure}

Using $x_k$ as the voltage for the input line $k$. The highest \ac{opAmp} is identified as $opAmp_0$ and the lowest $opAmp_1$.

For the sake of simplicity, the following equations considers the ground to be $V_{cm}$.

\begin{equation}
  \label{eq:doubleMem0}
  V_{opAmp_0}=-R_r\cdot i_+
\end{equation}
\begin{equation}
  \label{eq:doubleMem1}
  i_{R_f}=i_-+\frac{V_{opAmp_0}}{R_r}=i_--i_+
\end{equation}
\begin{equation}
  \label{eq:doubleMem2}
  \begin{array}{2}
    V_{opAmp_1}=y_0=-R_f\cdot(i_--i_+)=R_f\cdot(i_+-i_-)\\
    =R_f\cdot\sum_{k=0}^n(\sigma_{k+}-\sigma_{k-})\cdot x_k
  \end{array}
\end{equation}
With $i_+=\sum_{k=0}^n\sigma_{k+}\cdot x_k$ and $i_-=\sum_{k=0}^n\sigma_{k-}\cdot x_k$.

This circuit has the option to be serialized with varying degrees. The idea of serializing the circuit came from \cite{thesisRef}. Serializing the circuit reduces the number of components required and thus reduces the final onChip area. Serializing the system increases the time it takes to compute the output.

Serializing the system means not computing all values of the output vector at the same time, but instead computing group by group, the groups' size are $n_o$. The first output group is computed during $e_0$ and the $i^{th}$ group is computed during $e_i$. The timing of when the outputs are available is found in \cref{tim:serpar}. Those flag control the \ac{CMOS} swicthes present in \cref{circt:xbar}, the switches control which output group is outputed.

The \ac{CMOS} switches are here to open the necessary input gates when the output is required, the \ac{CMOS} switches are controlled as in \cref{tim:serpar}.

\begin{figure}[b]
  \centering
  \begin{tikztimingtable}
    $e_0$ & x2H2L N(A1) L N(A2) 2L N(A3) L N(A4) 2Lx\\
    $e_1$ & x2L2H N(B1) L N(B2) 2L N(B3) L N(B4) 2Lx\\
    $e_i$ & x4L N(C1) L N(C2) 2H N(C3) L N(C4) 2Lx\\
    $e_{n_s-1}$ & x4L N(D1) L N(D2) 2L N(D3) L N(D4) 2Hx\\
    %foo & 2L N(A1)  4H N(A2) L\\
    \extracode
    \node[gap, at={($(A1|-A2)!0.5!(A2)$)}];
    \node[gap, at={($(A3|-A4)!0.5!(A4)$)}];
    \node[gap, at={($(B1|-B2)!0.5!(B2)$)}];
    \node[gap, at={($(B3|-B4)!0.5!(B4)$)}];
    \node[gap, at={($(C1|-C2)!0.5!(C2)$)}];
    \node[gap, at={($(C3|-C4)!0.5!(C4)$)}];
    \node[gap, at={($(D1|-D2)!0.5!(D2)$)}];
    \node[gap, at={($(D3|-D4)!0.5!(D4)$)}];
    \tablerules
    %\draw (0,0) circle (2pt); % Origin
    \begin{pgfonlayer}{background}
      \vertlines[help lines]{0.55,10.55}
      %\vertlines[red]{1.6,5.6,15.6}
      %\vertlines[blue]{3.6,9.6,15.6}
    \end{pgfonlayer}
  \end{tikztimingtable}
  \caption{Enable flags timing for any value of $n_s$ in a single time step}
  \label{tim:serpar}
\end{figure}

When the system is used fully in parallel, the \ac{CMOS} switches are not required can then be removed to lower the final onChip area.

In this work, the analog system will be simulated for the inference of the \ac{NN}, thus the weights will not have to change during the simulation. Because the weights are represented in the analog circuit by the internal resistances of the memristors, the memristors can be replaced by resistors with a set resistance for the simulation.

The symbol (\cref{sym:xbar}) defined for the voltage based memristor crossbar array used in this thesis is more compact and helps the readability of the circuits that require a crossbar array. It depends on several parameters, the number of inputs ($n_i$), the number of outputs ($n_o$) and the serial size ($n_s$).

\begin{figure}[t]
  \centering
  \includesvg[height=1cm]{crossbar/xbarSymbol}
  \caption{Symbol used for the crossbar array, the input pin is a bus of size $n_i$ and the output pin is a bus of size $n_o$}
  \label{sym:xbar}
\end{figure}

\subsection{Verilog-A models}

This work uses Verilog-A components to replace component that could not be designed due to lack of time. Those components are the operational amplifier (opAmp) and a voltage multiplier.

\subsubsection{Operational amplifier}

This component is the very famous \ac{opAmp}. This specific component was not designed for the thesis, it required a current range that did not allow to use ones already made by members of the research group. The choice was then to use a verilog-A model, and then design one if time allows it.

\begin{equation}
  \label{eq:opAmp}
  V_{out}=\mu \cdot (V_+-V_-)
\end{equation}

\Cref{eq:opAmp} is the equation used in the verilog-A model. It makes it so it behaves like an ideal \ac{opAmp}. For this thesis $\mu$ has been set to $\mu=10^5$.

\subsubsection{Voltage multiplier}

This component while far less popular than the latter, is just as useful for our specific use. It allows us to multiply, as its name implies, two voltages. It is used to compute the pointwise multiplications of the \ac{LSTM} or \ac{GRU} (\cref{fig:lstmCell,fig:encoderGruCell}).

In oder for the circuit to be compliant with the real value to voltage conversion (\cref{tab:valConv}), a multiplication needs to be as in \cref{eq:finalVoltMult}.

\begin{equation}\label{eq:finalVoltMult}
  V_{out}=10\cdot(V_{in_1}-V_{cm})\cdot (V_{in_2}-V_{cm}) + V_{cm}
\end{equation}

This is taken care of using in reality two parts, the actual voltage multiplier (\cref{eq:voltMult}) and a non inverting amplifier (\cref{eq:invAmp}).

\begin{equation}\label{eq:voltMult}
  V_{voltMult}=-(V_{in_1}-V_{cm})\cdot (V_{in_2}-V_{cm}) + V_{cm}
\end{equation}
\begin{equation}\label{eq:invAmp}
  V_{out}=-(V_{voltMult}-V_{cm})\cdot10+V_{cm}
\end{equation}

Where $V_{out}$ is the output voltage the inverting amplifier, $V_{voltMult}$ is the out voltage of the voltage multiplier itself and $V_{in_1}$ and $V_{in_2}$ are the input voltages.

The \cref{eq:voltMult} is assumed possible because of the actual voltage multiplier's datasheet available at \cite{actualVoltMult}.

The symbols for those two components are the ones in \cref{sym:models}.

\begin{figure}[t]
  \centering
  \hspace*{1.5cm}
  \subfloat[\ac{opAmp}'s symbol\label{sym:opAmp}]{\includesvg[height=1cm]{models/opAmpSymbol}}%
  \hfill
  \subfloat[Voltage multiplier's symbol\label{sym:voltMult}]{\includesvg[height=1cm]{models/voltMultSymbol}}%
  \hspace*{1.5cm}
  \caption{Symbols used for the verilog-A components}
  \label{sym:models}
\end{figure}

The \ac{opAmp} uses its IEEE symbol (\cref{sym:opAmp}) while the voltage multiplier uses a custom symbol (\cref{sym:voltMult}).

\subsection{LSTM analog implementation}

This section describes the circuit of an \ac{LSTM} with an input vector of size $n_i$, a $n_h$ hidden states, a serial size of $n_s$ and $n_{ts}$ time steps. $n_o=n_h/n_s$ is going to be used for future references in this section. In order for the crossbar array to be used $n_o$ must be an integer, in other words, $n_s$ must divide $n_h$. The circuit used for the LSTM is shown in \cref{circt:lstm}.

\begin{figure*}[h]
  \centering
  \includesvg[width=\textwidth,pretex=\tiny]{lstm/lstmCircuit}
  \caption{\ac{LSTM} circuit}
  \label{circt:lstm}
\end{figure*}

The system is built using the crossbar array from \cref{subsec:xbarCircuit} with ($n_i+n_h+1$,$n_o$, $n_s$) as parameters.

\begin{itemize}
  \item $\overrightarrow{z_t}$ is the input of the crossbar but not the input of the \ac{LSTM}. It is defined by $\overrightarrow{z_t}=(\overrightarrow{x_t},\overrightarrow{h_{t-1}},\overrightarrow{b})$.
  \item $e_{j,0}$ and $e_{j,1}$ are two enable flags that respectively represent the first and second half of $e_j$.
  \item $e_{in}$ and $e_{out}$ are the flags used to enable the hidden state values to go to the input (feedback connection) or to the output of the circuit.
  \item $e_{next}$ is the enable flag on in between two time steps.
  \item $R_{amp0}$ and $R_{amp1}$ are the two resistances used to amplify the output voltage of the voltage multipliers. Their value is set so that $\frac{R_{amp1}}{R_{amp0}}=10$.
\end{itemize}

The wires coming into the crossbar are a bus of size $n_i+n_h+1$ and the output of the crossbar is a bus of size $n_o$ (\cref{sym:xbar}). This is why everything in the system apart from the crossbar arrays is only shown once in \cref{circt:lstm} but in reality those components are present $n_o$ times. Those extra components are needed in order for the parallel channels to work.

The circuit uses two memory cells for its feedback connections not to overwrite the value of the current stored value by the value of the next time step.

The LSTM circuit can be serialized allowing to reduce the number of pointwise components in the circuit by a factor $n_s$. However serializing the circuit increases the times it takes to compute the outputs by a factor of $n_s$.

\subsection{GRU analog implementation}

This section describes the circuit of an encoder \ac{GRU} with an input vector of size $n_i$, a $n_h$ hidden states and $n_{ts}$ time steps. The decoder \ac{GRU} could also be implemented in an analog circuit, but the choice was made to focus on the encoder \ac{GRU}. The \ac{GRU} is by its nature very similar to the \ac{LSTM}. For that reason it has a similar circuit to LSTM circuit (\cref{circt:lstm}). The system is built, once again, using crossbar array with ($n_i+n_h+1$,$n_h$, $1$) as parameters.

The GRU equations requires to compute the function defined in \cref{eq:1minus0}.
\begin{equation}\label{eq:1minus0}
  f(x)=1-x
\end{equation}
The solution found to do compute the operation consist of using an \ac{opAmp} as an inverter around $V_{inv}$, the formula is available in \cref{eq:1minus1}.
\begin{equation}\label{eq:1minus1}
  f_v(v)=-(v-V_{inv})+V_{inv}=2\cdot V_{inv} -v
\end{equation}
With $V_{inv}=V_{cm}+0.05$.

The GRU circuit cannot be serialized. This is because the candidate hidden state requires a fully computed reset vector to be computed.
