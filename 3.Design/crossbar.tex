\section{Voltage-driven crossbar circuit}
\label{sec:xbarCircuit}

The crossbar circuit theory has already been explained in the \cref{sec:crossbar}. This section describes how the crossbar circuit is actually implemented. The final circuit is the one in \cref{circt:xbar}. The circuit depends on three parameters :
\begin{itemize}
  \item $n_i$ : The number of input for our crossbar array (not including bias for a more general circuit).
  \item $n_o$ : The number of parallel output for our crossbar array.
  \item $n_s$ : The serial size of our crossbar system.
\end{itemize}

\begin{figure}[H]
  \centering
  \includesvg[width=\textwidth]{crossbar/crossbarUse}
  \caption{Circuit of the crossbar array used in the final system ($n_i$, $n_o$, $n_s$)}
  \label{circt:xbar}
\end{figure}

The parallel and serial are explained later (\cref{subsec:serpar}).

The enable flags ($e_j,\forall j\in[\![ 0,n_s]\!]$ and similarly $\overline{e_j}$) are there to show when the \ac{CMOS} switches are open, the states of those flags is shown in \cref{tim:serpar}.

\subsection{Two memristors per synapse}
\label{subsec:doubleMem}

First of all, a two memristors per synapse architecture has been used. This design is beneficial in two ways :

\begin{itemize}
  \item It doubles the range of weights (\cref{tab:synapses})
  \item It allows to easily use negative weights, as this design simply allows the output values to be centered around $V_{cm}$ to be compliant with the standard set in \cref{tab:valConv}.
\end{itemize}

This design is the one that is used in \cite{doubleMem}. Let's assume that a given memristor has a resistance range of $R\in[R_{min},R_{max}]$, that means it's conductance range is $\sigma \in [\sigma_{min},\sigma_{max}]$ (with $\sigma_{min}= \frac{1}{R_{max}}$ and $\sigma_{max}= \frac{1}{R_{min}}$). This design works using two \ac{opAmp} connected to $V_{cm}$ with the positive pin and the negative pin to the output of the crossbar array. \Cref{eq:doubleMem0,eq:doubleMem1,eq:doubleMem2} are describing how this architecture works. A simplified version of the double memristors per synapse circuit is also available in \cref{circt:doubleMem}.

\begin{figure}[H]
  \centering
  \includesvg[height=8cm]{crossbar/doubleMem}
  \caption{Simplified circuit of a double memristor per synapse architecture}
  \label{circt:doubleMem}
\end{figure}

With $x_k$ being the voltage for the input line $k$. The highest \ac{opAmp} is identified as opamp0 and the lowest opamp1.

For the sake of simplicity, the following equations considers the ground to be $V_{cm}$.

\begin{equation}
  \label{eq:doubleMem0}
  V_{opAmp0}=-R\cdot i_+ \Leftrightarrow
\end{equation}
\begin{equation}
  \label{eq:doubleMem1}
  i_{R_f}=i_-+\frac{V_{opAmp0}}{R}=i_--i_+
\end{equation}
With $i_{opAmp}=0A$ because we assume an ideal \ac{opamp}.
\begin{equation}
  \label{eq:doubleMem2}
  V_{opAmp2}=y_0=-R_f\cdot(i_--i_+)=R_f\cdot(i_+-i_-)=R_f\cdot\sum_{k=0}^n(\sigma_{k+}-\sigma_{k-})\cdot x_k
\end{equation}
With $i_+=\sum_{k=0}^n\sigma_{k+}\cdot x_k$ and $i_-=\sum_{k=0}^n\sigma_{k-}\cdot x_k$.


\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \cline{2-3}
    \rowcolor{gray}
    \multicolumn{1}{c|}{\cellcolor[HTML]{FFFFFF}} & Two memristors per synapse & One memristor per synapse \\
    \hline
    Maximum weight & $\sigma_{max}-\sigma_{min}$ & $\sigma_{max} -\overline{\sigma}$\\
    \hline
    Minimum weight & $\sigma_{min}-\sigma_{max}$ & $\sigma_{min} -\overline{\sigma}$\\
    \hline
    Range & $2\cdot(\sigma_{max}-\sigma_{min})$&$\sigma_{max}-\sigma_{min}$\\
    \hline
  \end{tabular}
  \caption{Synaptic weights precision (extracted from \cite{doubleMem})}
  \label{tab:synapses}
\end{table}

\subsection{Serialization/Parallelization}
\label{subsec:serpar}

The idea using the system in a serial mode came from \cite{thesisRef}. The principle of this system is to save onChip area by reducing the number of \ac{opAmp} required. It also, and mainly reduces the point wise part of the \ac{LSTM} circuit.

This serial system has great advantages but comes with a few down sides. Let's assume the number of hidden state ($n_h$) is the major changing element in the final system(TODO ref final onchip area).

\begin{itemize}
  \item When the system is serialized, the inference time increases with a factor of $O(n_h)$.
  \item When the system is in parallel, the circuit onChip area increases with a factor of $O(n_h)$.
\end{itemize}

However, in both cases, the overall onChip area increases with a factor of $O(n_h^2)$. That means that using the parallel system won't increase the onChip area by a lot as $n_h$ rises, because the $O(n_h)$ factor of the parallel version is absorbed as $O(n_h^2+n_h)=O(n_h^2)$.

That leads to the conclusion that the best thing to do is use a both serialized and parallel system, using the limiting inference time for our system to set the maximum serial size. Depending on the system we're using this circuit for, we might have different time requirements.

The \ac{CMOS} switches are here to open the necessary input gates when the output is required, the gates are controlled as in \cref{tim:serpar}.
\begin{figure}[H]
  \centering
  \begin{tikztimingtable}%TODO change or find other way
    $e_0$ & xH3Lx\\
    $e_1$ & xLH2Lx\\
    $e_2$ & x2LHLx\\
    $e_3$ & x3LHx\\
    \extracode
    \tablerules
    %\draw (0,0) circle (2pt); % Origin
    \begin{pgfonlayer}{background}
      \vertlines[help lines]{0.6,4.6}
      %\vertlines[red]{1.6,5.6,15.6}
      %\vertlines[blue]{3.6,9.6,15.6}
    \end{pgfonlayer}
  \end{tikztimingtable}
  \caption{Example of enable flags timing with $n_s=4$ in a single time step}
  \label{tim:serpar}
\end{figure}

%TODO understand better \subsection{Sneak path problem}
\subsection{Symbol}
The symbol (\cref{sym:xbar}) defined for the voltage based memristor crossbar array used in this thesis is more compact and helps the readability of the final circuit. It contains the size of each parameters on its symbol. It depends on several parameters, the number of inputs ($n_i$), the number of outputs ($n_o$) and the serial size ($n_s$).

\begin{figure}[H]
  \centering
  \includesvg[height=2.5cm]{crossbar/xbarSymbol}
  \caption{Symbol used for the crossbar array}
  \label{sym:xbar}
\end{figure}

The total onChip area for the crossbar circuit depends on the previously defined parameters.

\begin{equation}
  A_{xbar}(n_i,n_o,n_s)=2\cdot n_i\cdot n_o \cdot n_s\cdot A_{memristor}+2\cdot A_{CMOS}\cdot n_o\cdot n_s +n_o\cdot(2\cdot[A_{opAmp}+A_R]+A_{R_f})
\end{equation}

With $A_{CMOS}$ being the same than for the memory cell (\cref{sec:memcell}), $A_{CMOS}=1.2\cdot 10^{-14}m^2$, and the feature size of typical memristor that can be fabricated at INESC is $3\mu m$, which would make the approximate area for a memristor $A_{memristor}=9\mu m^2=9\cdot 10^{-12} m^2$.%TODO check info and inesc citation

\subsection{Usage}

%TODO Show off results ??

The crossbar system, and in a more general manner, the entire system will require an external controller to control the enable flags that are required in the system. Adding such a system will increase the power consumption of the overall system. However, due to the slow (precision of about $1\mu s$) nature of those signals, the controller will be very low power, and won't change the overall power consumption of the final system. This controller is not needed for the simulation as everything is managed within Cadence's virtuoso. In the real circuit, the enable signals need to be controlled somehow.%TODO maybe move to final circuit

The analog system is only simulated in the inference phase of the \ac{NN}. And since the weights only change during the training phase, and the resistances are just a rendition of the weights (\cref{sec:wei2res}), the resistances don't need to change, the circuit used in the simulations is thus using resistors instead of memristors for the sake of simplicity, as importing resistors are way easier to import in Cadence's virutoso.
