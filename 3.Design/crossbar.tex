\section{Voltage-driven crossbar circuit}
\label{sec:xbarCircuit}

The crossbar circuit theory has already been explained in the \cref{sec:crossbar}. This section describes how the crossbar circuit is actually implemented. The final circuit is the one in \cref{circt:xbar}.

\begin{figure}[H]
  \centering
  \includesvg[width=\textwidth]{crossbar/crossbarUse}
  \caption{Crossbar circuit used in the final system}
  \label{circt:xbar}
\end{figure}

\subsection{Two memristors per synapse}

First of all, a two memristors per synapse architecture has been used. This design is beneficial in two ways :

\begin{itemize}
  \item It doubles the range of weights (\cref{tab:synapses})
  \item It allows to easily use negative weights, as this design simply allows the output values to be centered around $V_{cm}$ to be compliant with the standard set in \cref{tab:valConv}.
\end{itemize}

This design is the one that is used in \cite{doubleMem}. Let's assume that a given memristor has a resistance range of $R\in[R_{min},R_{max}]$, that means it's conductance range is $\sigma \in [\sigma_{min},\sigma_{max}]$ (with $\sigma_{min}= \frac{1}{R_{max}}$ and $\sigma_{max}= \frac{1}{R_{min}}$). This design works using two \ac{opAmp} connected to $V_{cm}$ with the positive pin and the negative pin to the output of the crossbar array. \Cref{eq:doubleMem0,eq:doubleMem1,eq:doubleMem2} are describing how this architecture works.

% For the sake of simplicity, the following equations considers the ground to be $V_{cm}$.

\begin{equation}
  \label{eq:doubleMem0}
  V_{opAmp0}=-R\cdot i_+ \Leftrightarrow
\end{equation}
\begin{equation}
  \label{eq:doubleMem1}
  i_{R_f}=i_-+\frac{V_{opAmp0}}{R}=i_--i_+
\end{equation}
With $i_{opAmp}=0A$ because we assume an ideal \ac{opamp}.
\begin{equation}
  \label{eq:doubleMem2}
  V_{opAmp2}=V_{out}=-R_f\cdot(i_--i_+)=R_f\cdot(i_+-i_-)=R_f\cdot\sum_{k=0}^n(\sigma_{k+}-\sigma_{k-})\cdot x_k
\end{equation}
With $i_+=\sum_{k=0}^n\sigma_{k+}\cdot x_k$ and $i_-=\sum_{k=0}^n\sigma_{k-}\cdot x_k$.

In \cref{eq:doubleMem0,eq:doubleMem1,eq:doubleMem2}, $x_k$ is the voltage for the input line $k$.

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \cline{2-3}
    \rowcolor{gray}
    \multicolumn{1}{c|}{\cellcolor[HTML]{FFFFFF}} & Two memristors per synapse & One memristor per synapse \\
    \hline
    Maximum weight & $\sigma_{max}-\sigma_{min}$ & $\sigma_{max} -\overline{\sigma}$\\
    \hline
    Minimum weight & $\sigma_{min}-\sigma_{max}$ & $\sigma_{min} -\overline{\sigma}$\\
    \hline
    Range & $2\cdot(\sigma_{max}-\sigma_{min})$&$\sigma_{max}-\sigma_{min}$\\
    \hline
  \end{tabular}
  \caption{Synaptic weights precision (extracted from \cite{doubleMem})}
  \label{tab:synapses}
\end{table}

\subsection{Serialization/Parallelization}

The idea using the system in a serial mode came from \cite{thesisRef}. The principle of this system is to save onChip area by reducing the number of \ac{opAmp} required. It also, and mainly reduces the point wise part of the \ac{LSTM} circuit.

This serial system has great advantages but comes with a few down sides. Let's assume the number of hidden state ($n_h$) is the major changing element in the final system(TODO ref final onchip area).

\begin{itemize}
  \item When the system is serialized, the inference time increases with a factor of $O(n_h)$.
  \item When the system is in parallel, the circuit onChip area increases with a factor of $O(n_h)$.
\end{itemize}

However, in both cases, the overall onChip area increases with a factor of $O(n_h^2)$. That means that using the parallel system won't increase the onChip area by a lot as $n_h$ rises, because the $O(n_h)$ factor of the parallel version is absorbed as $O(n_h^2+n_h)=O(n_h^2)$.

That leads to the conclusion that the best thing to do is use a both serialized and parallel system, using the limiting inference time for our system to set the maximum serial size. Depending on the system we're using this circuit for, we might have different time requirements.

%TODO understand better \subsection{Sneak path problem}
\subsection{Symbol}
This is the symbol defined for the voltage based memristor crossbar array used in this thesis for a better undertsanding of the future circuits. It depends on several parameters, the number of inputs ($n_i$), the number of outputs ($n_o$) and the serial size ($n_s$).

%TODO : include figure

The total onChip area for the crossbar circuit depends on the previously defined parameters.

\begin{equation}
  A_{xbar}(n_i,n_o,n_s)=2\cdot n_i\cdot n_o \cdot n_s\cdot A_{memristor}+2\cdot A_{CMOS}\cdot n_o\cdot n_s +n_o\cdot(2\cdot[A_{opAmp}+A_R]+A_{R_f})
\end{equation}

With $A_{CMOS}$ being the same than for the memory cell (\cref{sec:memcell}), $A_{CMOS}=1.2\cdot 10^{-14}m^2$, and the feature size of typical memristor that can be fabricated at INESC is $2\mu m$, which would make the approximate area for a memristor $A_{memristor}=4\mu m^2=4\cdot 10^{-12} m^2$.%TODO check info and inesc citation

\subsection{Usage}

TODO Show off results

The analog system is only simulated in the inference phase of the \ac{NN}. And since the weights only change during the training phase, and the resistances are just a rendition of the weights (TODO : ref weigths to res), the resistances don't need to change, the circuit used in the simulations is thus using resistors instead of memristors for the sake of simplicity (notably in generating the netlist of the system, TODO ref how hard it is to import parameters using spice netlists).
