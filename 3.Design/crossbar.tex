\section{Crossbar circuit}
\label{sec:xbarCircuit}

The crossbar circuit theory has already been explained in the \cref{sec:crossbar}. This section describes how the crossbar circuit is actually implemented. The final circuit is the one in \cref{circt:xbar}.

\begin{figure}[H]
  \centering
  \includesvg[width=\textwidth]{crossbar/crossbarUse}
  \caption{Crossbar circuit used in the final system}
  \label{circt:xbar}
\end{figure}

\subsection{Two memristors per synapse}

First of all, a two memristors per synapse architecture has been used. This design is beneficial in two ways :

\begin{itemize}
  \item It doubles the range of weights (\cref{tab:synapses})
  \item It allows to easily use negative weights, as this design simply allows the output values to be centered around $V_{cm}$ to be compliant with the standard set in \cref{tab:valConv}.
\end{itemize}

This design is the one that is used in \cite{doubleMem}. Let's assume that a given memristor has a resistance range of $R\in[R_{min},R_{max}]$, that means it's conductance range is $\sigma \in [\sigma_{min},\sigma_{max}]$ (with $\sigma_{min}= \frac{1}{R_{max}}$ and $\sigma_{max}= \frac{1}{R_{min}}$). This design works using two \ac{opAmp} connected to $V_{cm}$ with the positive pin and the negative pin to the output of the crossbar array. \Cref{eq:doubleMem0,eq:doubleMem1,eq:doubleMem2} are describing how this architecture works.

% For the sake of simplicity, the following equations considers the ground to be $V_{cm}$.

\begin{equation}
  \label{eq:doubleMem0}
  V_{opAmp0}=-R\cdot i_+ \Leftrightarrow
\end{equation}
\begin{equation}
  \label{eq:doubleMem1}
  i_{R_f}=i_-+\frac{V_{opAmp0}}{R}=i_--i_+
\end{equation}
With $i_{opAmp}=0A$ because we assume an ideal \ac{opamp}.
\begin{equation}
  \label{eq:doubleMem2}
  V_{opAmp2}=V_{out}=-R_f\cdot(i_--i_+)=R_f\cdot(i_+-i_-)=R_f\cdot\sum_{k=0}^n(\sigma_{k+}-\sigma_{k-})\cdot x_k
\end{equation}
With $i_+=\sum_{k=0}^n\sigma_{k+}\cdot x_k$ and $i_-=\sum_{k=0}^n\sigma_{k-}\cdot x_k$.

In the previous equations, $x_k$ is the voltage for the input line $k$.

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \cline{2-3}
    \rowcolor{gray}
    \multicolumn{1}{c|}{\cellcolor[HTML]{FFFFFF}} & Two memristors per synapse & One memristor per synapse \\
    \hline
    Maximum weight & $\sigma_{max}-\sigma_{min}$ & $\sigma_{max} -\overline{\sigma}$\\
    \hline
    Minimum weight & $\sigma_{min}-\sigma_{max}$ & $\sigma_{min} -\overline{\sigma}$\\
    \hline
    Range & $2\cdot(\sigma_{max}-\sigma_{min})$&$\sigma_{max}-\sigma_{min}$\\
    \hline
  \end{tabular}
  \caption{Synaptic weights precision (extracted from \cite{doubleMem})}
  \label{tab:synapses}
\end{table}

\subsection{Serialization/Parallelization}

The idea using the system in a serial mode came from \cite{thesisRef}. The principle of this system is to save onChip area by reducing the number of \ac{opAmp} required. It also, and mainly reduces the point wise part of the \ac{LSTM} circuit.

This serial system has great advantages but comes with a few down sides. Let's assume the number of hidden state ($n_h$) is the major changing element in the final system(TODO ref final onchip area).

\begin{itemize}
  \item When the system is serialized, the inference time increases with a factor of $O(n_h)$.
  \item When the system is in parallel, the circuit onChip area increases with a factor of $O(n_h)$.
\end{itemize}

However, in both cases, the overall onChip area increases with a factor of $O(n_h^2)$. That means that using the parallel system won't increase the onChip area by a lot as $n_h$ rises, because the $O(n_h)$ factor of the parallel version is absorbed as $O(n_h^2+n_h)=O(n_h^2)$.

That leads to the conclusion that the best thing to do is use a both serialized and parallel system, using the limiting inference time for our system to set the maximum serial size.

%TODO understand better \subsection{Sneak path problem}
\subsection{Usage}
Since the analog system is only simulated in the inference phase of the \ac{NN}, the resistances don't need to change, the circuit used in the simulations are thus using resistors instead of memristors for the sake of simplicity (notably in generating the netlist of the system, TODO ref how hard it is to import parameters using spice netlists). The weights only change during the training phase, and the resistances are just a rendition of the weights (TODO : ref weigths to res).
