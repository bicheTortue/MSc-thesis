\section{\ac{LSTM} analog implementation}\label{sec:lstmCircuit}

\subsection{Circuit}

This section describes the circuit of an \ac{LSTM} with an input vector of size $n_i$, a $n_h$ hidden states, a serial size of $n_s$ and $n_{ts}$ time steps. $n_o=n_h/n_s$ is going to be used for future references in this section. In order for the crossbar array to be used $n_o$ must be an integer, in other words, $n_s$ must divide $n_h$. The circuit (shown in \cref{circt:lstm}) is pretty complex and contains numerous parts that require explaination.

\begin{figure}[H]
  \centering
  \includesvg[width=\textwidth,pretex=\tiny]{lstm/lstmCircuit}
  \caption{\ac{LSTM} circuit}
  \label{circt:lstm}
\end{figure}

The system is built using crossbar array (\cref{sec:xbarCircuit}) with ($n_i+n_h+1$,$n_o$, $n_s$) as parameters.

First of all, the different vectors and variables present in the schematic have to be described :

\begin{itemize}
  \item $\overrightarrow{x_t}$ : This is the input vector for the \ac{LSTM} circuit at time $t$. It has a size of $n_i$.
  \item $\overrightarrow{h_t}$ : This is the hidden layer vector for the feedback connections, it is defined as $\overrightarrow{h_t}=(\overrightarrow{h_{t,i}}) \forall i\in [\![0,n_o-1]\!]$, with $\overrightarrow{h_{t,i}}=(h_{t,i,j}) \forall j\in [\![0,n_s-1]\!]$.
  \item $\overrightarrow{z_t}$ is the input of the crossbar but not the input of the \ac{LSTM}. This vector is there to lighten the informations on the schematic (\cref{circt:lstm}). $\overrightarrow{z_t}$ is defined by $\overrightarrow{z_t}=(\overrightarrow{x_t},\overrightarrow{h_{t-1}},b)$.
  \item $e_{j,0}$ and $e_{j,1}$ are two enable flags that respectively represent the first and second half of $e_j$.
  \item $e_{in}$ and $e_{out}$ are the flags used to enable the hidden state values to go to the input (feedback connection) or to the output of the circuit.
  \item $e_{next}$ is the enable flag on in between two time steps.
  \item $R_{amp0}$ and $R_{amp1}$ are the two resistances used to amplify the output voltage of the voltage multipliers. The ratio of the resistances value must of $\frac{R_{amp1}}{R_{amp0}}=10$. The resistances must stay arround the values of the resistances used around the circuit, especially those of the memristors.
\end{itemize}

The wires coming into the crossbar are a bus of size $n_i+n_h+1$ and the output of the crossbar is a bus of size $n_o$. This is why everything in the system apart from the crossbar arrays is only shown once in \cref{circt:lstm} but in reality those components are present $n_o$ times. Those extra components are needed in order for the parallel channels to work.

\subsection{Doubling memory cells}

\subsubsection{Feedback hidden states}

In order for the system to work in serial mode, the memory cells of the output need to be doubled. This is done in \cref{circt:lstm}, and allows for the hidden states to be saved for the next stage. Indeed, if using the system in serial mode with only one line of memory cells, the old hidden state ($\overrightarrow{h_{t-1}}$) is slowly overwritten by the current hidden state ($\overrightarrow{h_t}$). As soon as the first $n_o$ serial values are computed, they are going to override the old ones, still required for the following serial values. \Cref{tim:lstmMemcell} shows that the value in the memory cell changes too early in the cycle and gives a bad input for the next serial values. The value given to the input of the \ac{LSTM} should always be the old hidden state ($\overrightarrow{h_{t-1}}$).

\begin{figure}[H]
  \centering
  \begin{tikztimingtable}
    $e_{n_s-1}$ & 3H8Lx \\
    $e_0$ & 3L4H4Lx \\
    $e_1$ & 7L4Hx \\
    $m_{i,0}$ & 3D{$h_{t-1,i,0}$}8D{$h_{t,i,0}$}x \\
    $m_{i,1}$ & 7D{$h_{t-1,i,1}$}4D{$h_{t,i,1}$}x \\
    \extracode
    \tablerules
    %\draw (0,0) circle (2pt); % Origin
    \begin{pgfonlayer}{background}
      \vertlines[help lines]{3.05}
      %\vertlines[red]{1.6,5.6,15.6}
      %\vertlines[blue]{3.6,9.6,15.6}
    \end{pgfonlayer}
  \end{tikztimingtable}
  \caption{Time diagram of the values in the different memory cells ($m_{i,j}$ being the value stored in the $i^{th}$ parallel memory cells for the $j^{th}$ serial value). It is assumed that $n_s>1$ (the system is in serial mode). This graph does not take into account the pauses $e_{next}$ between the time steps.}
  \label{tim:lstmMemcell}
\end{figure}

Using two memory cells when in serial mode allows for this issue to be elevated. The values are transfered from one level to an other at the end of the time step. That way, the values are updated safely during each time step, without changing the final output.

When the system is running is a fully parallel mode, doubling the memory cells serves no purpose, and the system can then use only one line of memory cell to save onChip area.

\subsubsection{Cell states}

Cell states have the same solution to a similar problem. Here the problem is that the old cell state value needs to be used to compute the current values for the hidden states ($\overrightarrow{h_t}$) and cell states ($\overrightarrow{c_t}$). The issue is that at the value in the memory cell needs to be conserved until the next serial step. This means the time restraints for this issue is much smaller than for the latter. It could possibly allow for another solution to save onChip area (\cref{subsec:noDoubleMemcell}).

Once again, when the system is running in fully parallel mode, only one memory cell line is required for a normal behavior.

\subsection{}
